---
title: 第 1 部分面试题
description: 第 1 部分面试题
---

### Spring Bean 的五个作用域

| 类别          | 说明                                                                                                                                                       |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| singleton     | Spring IOC 容器一开始就会实例化该 Bean，且在整个 Spring IOC 容器中，使用 singleton 定义的 Bean 将只有一个实例                                              |
| prototype     | Spring IOC 容器一开始不会实例化该 Bean，而是每次通过容器的 getBean() 方法获取 prototype 定义的 Bean 时，都将产生一个新的 Bean 实例                         |
| request       | 对于每次 HTTP 请求，使用 request 定义的 Bean 都将产生一个新实例，即每次 HTTP 请求将会产生不同的 Bean 实例，只有在 Web 应用中使用 Spring 时，该作用域才有效 |
| session       | 同一个 Http Session 共享同一个 Bean ，不同的 Http Session 使用不同的 Bean，同样只有在 Web 应用中使用 Spring 时，该作用域才有效                             |
| globalsession | 同一个全局 Session 共享同一个 Bean，一般用于 Portlet 应用环境，同样只有在 Web 应用中使用 Spring 时，该作用域才有效                                         |

其中比较常用的是 singleton 和 prototype 两种作用域。对于 singleton 作用域的 Bean，每次请求该 Bean 都将获得相同的实例，容器负责跟踪 Bean 实例的状态，负责维护 Bean 实例的生命周期；如果一个 Bean 被设置成 prototype 作用域，程序每次请求该 ID 的 Bean 时，Spring 都会新建一个 Bean 实例，然后返回给程序。在这种情况下，Spring 容器仅仅使用 new 关键字创建 Bean 实例，一旦创建成功，容器不再跟踪 Bean 实例，也不会维护 Bean 实例的状态。如果不指定 Bean 的作用域，Spring 默认使用 singleton 作用域。Java 在创建实例时，需要进行内存申请；在销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype 作用域下 Bean 的创建、销毁代价比较大；而 singleton 作用域的 Bean 实例一旦创建成功，可以重复使用。因此，除非必要，应尽量避免将 Bean 被设置成 prototype 作用域。

### Spring 的七种事务传播行为

::: tip 事务传播行为的定义
事务传播行为是指一个事务方法运行在了一个开启了事务的方法中时，当前方法（前者）是使用正在运行的事务，还是开启一个新的事务。
:::

当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能在现有的事务中运行，也可能开启一个新的事务，并在自己的事务中运行。Spring 定义了七种事务传播行为，默认的事务传播行为是 `REQUIRED`。

| 事务传播行为  | 说明                                                                                                       |
| ------------- | ---------------------------------------------------------------------------------------------------------- |
| REQUIRED      | 如果有事务正在运行，当前方法就在这个事务内运行，否则就启动一个新的事务，并在自己的事务内运行               |
| REQUIRES_NEW  | 当前方法必须启动一个新的事务，并在自己的事务内运行，如果有事务正在运行，应该将它挂起                       |
| SUPPORTS      | 如果有事务正在运行，当前方法就在这个事务内运行，否则它可以不运行在事务中                                   |
| NOT_SUPPORTED | 当前方法不应该运行在事务中，如果有正在运行的事务，应该将它挂起                                             |
| MANDATORY     | 当前方法必须运行在事务内部，如果没有正在运行的事务，则抛出异常                                             |
| NEVER         | 当前方法不应该运行在事务中，如果有正在运行的事务，则抛出异常                                               |
| NESTED        | 如果有事务正在运行，当前方法就应该在这个事务的嵌套事务内运行，否则就启动一个新的事务，并在自己的事务内运行 |

::: tip 提示
在 Spring 框架中，事务传播行为可以通过 `@Transactional` 注解中的 `propagation` 属性定义。
:::
